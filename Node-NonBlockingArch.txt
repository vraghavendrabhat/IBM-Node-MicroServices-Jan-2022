					Node.js
What is Node.js?

  Node.js is platform and runtime for javascript lang.

Platform: collection of tools
Runtime: Execution engine where javascript can be executed..



Why Node.js?

History of Node.js:

Ryan Dahl who created Node.js.
When he was doing phd in math, who got bored in math , so who
started working on different project by looking the project "flicker" , he was thinking how flicker uploades photos into server.

He attended conference "nginx" conference where who insipred "Non Blocking" Web Server.

He started thinking how to build nginx like server to build web application -  non blocking webservers.

He was thinking how to put java language, but java language was not ready for non blocking computing.Why cant use "javascript", javascript inside browser is non blocking language.

The same time, google published "open source javascript runtime" called v8.

Ryan thought using v8 we can build arch for building non blocking web servers.===>Node.js
..............................................................................................
			Node.js was created to built NonBlocking Network Apps
..............................................................................................

What is Exactly Non Blocking , Blocking? 
  
IO,Threads

What is IO? How IO Works underneeth?


File Descriptor:
................

-FD is a datastructure presented inside os kernal at very low level
-FD is mapper between os and hardware layer
-FD is entry and exit point of os with IO layer
-FD is simple c program.
-FD is broker for io between applications and io os layer

Process:
 File Descriptor is simple c programming, getting loaded into memory once the process inthe
application is started.

Every Process has its own File Descriptor.

Here i have "notepad" - application, when i start notepad , os will create file descriptor in memory.


FD is a table contains information which maps to IO resources

Integer value	Name	<unistd.h> symbolic constant[1]	<stdio.h> file stream[2]
0	Standard input	STDIN_FILENO	stdin
1	Standard output	STDOUT_FILENO	stdout
2	Standard error	STDERR_FILENO	stderr

FD is very simple array.

IO operations and file Descriptors:
....................................

IO opertions can vary from reading data from the keyboard to reading data from disk files and network sockets.

When y read data from the keyboard via FDS it is always done via 0th index of fd.

Use case: 
 I want to read data from the disk file.

if you take any pl, who provides io apis. java.io package and apis 

There are two apis

1.High level api provided by language like java,c,c++..
2.Low level api provided by os - windows,linux,unix,mac....

Flow

Programming language high level api-------> OS low level api------> File Descriptor----|HL

.............................................................................................
			Networking and IO : Network IO: Internet
..............................................................................................

Client -Server Architecture :  WebServer Working Model
......................................................

Threading Model:

                         "Request Per Thread Model"


Client-----request(io request)----WebServer--new Thread----Starts handling io operation

100 request = 100 threads

10000 request =10000 threads
..............................................................................................

		C10k : concurrently handling ten thousand connections


C10k is one of the real time problem, expectation was if web server able to handle
10k connections, then it is good infra structure,so i dont need to add more machines.

How to reduce servers , how to utilize the existing hardware resouces.

Linux operating system added feature to manage threads , if any idle thread, os will put in 
sleep state, if data ready, linux operating system again makes that thread active.
	...................................................................................

	bjective how to reduce more threads and keep less threads for io operation.
.............................................................................................
				Birth of non blocking arch



in 2000, linux operating system added new api for performing non blocking io operations.

Non blocking api model

Application will call

  select------------->kernal
  
  <-------------------

  read--------------->
     <-----copy the data

The first non blocking arch -----> select + read api call

.........................................................................................

Poll Api:
..........

 Similar to select but we dont need to fire extra read call but data will be available : Event driven programming.
.............................................................................................


Multi threading and evils:
...........................

Thread creation requires more memory
Every thread is need to be controlled by cpu - ctx switch
if thread is blocked longer time, thread deadlocks,race conditions

Non blocking arch helps to reduce more threads, how to reuse exisiting threads
..............................................................................................
				EPoll
..............................................................................................

->It is framework for monitoring fd
   Monitoring means
     if any entry is made , watch it for data

Which is used to build non blocking,event driven arch.

..............................................................................................
				Node.js and Non blocking , event driven 


Node.js:

-Multi platform, non blocking ,event processing archiecture.
-Reduces more threads,having limited threads-single thread for event processing.
-Suitable for large network concurrency applications.


Node.js components:

1.V8  - Javascript Engine
2.libuv - Platform abstraction Engine

Node io operations are classified into 2 category

1.file io/disk io

2.network io/socket io


Types of threads in node:

1.Event loop thread
  It is single thread , responsible for handling all network related non blocking calls.
  Event loop thread watches/listens for incoming network related events
  if any events comes from the kernal , which process those events

 Dont block event loop thread, if you block event loop thread, the entire node process will be blocked.
 

2.Worker pool thread
  It is collection of threads for handling non blocking io and blocking io calls.
  

libuv:
  libuv is a multi-platform support library with a focus on asynchronous I/O.
  libuv is collection of c apis for multiple operating system
    -libuv works with epoll in linux
    -libuv works with kqueue in mac/open bsd os
    -libuv works with iocp in windows

Features:

Full-featured event loop backed by epoll, kqueue, IOCP, event ports.
Asynchronous TCP and UDP sockets
Asynchronous DNS resolution
Asynchronous file and file system operations
File system events
ANSI escape code controlled TTY
IPC with socket sharing, using Unix domain sockets or named pipes (Windows)
Child processes
Thread pool
Signal handling
High resolution clock
Threading and synchronization primitives


libuv contains:

1. event loop thread:

  This is demaon thread, starts spinning for listening for incomming events from os kernal space.

2.Thread Pools
   libuv maintains set of threads other than event loop thread for doing "BLOCKING" IO operations.

Warining; 
   dont over use thread pools , because if use more threads from the thread poll then it impacts performance,memory...
   Dont block event loop thread.

............................................................................................
Node solves the problem multithreading networking problems from request per thread model to                                resuable thread model.
..............................................................................................

how to build Async ,Non blocking Applications on node?

Requirments:

1.you need os which should support non blocking apis

2.you need language /lib /framework which should have api to communicate os


Node js and non blocking api:

Node.js provides high level javascript api for building non blocking applications on all operating system.

API classifcation:

1.io apis
   fs io
   network io  

2.other apis
 timer api
 processing apis

....
How to process events?
 Node is non blocking having single event loop thread, which is listening for events emitted by kernal incase data is avaiable, or something happened.

Three style of writing code

1.callback based
2.promise based
3.async..await

........

How to run js code on node?

1.you can initalize node process by suppling javascript program

2.you can REPL prompt


Timer api: 
 used for scheduling async tasks




function sayHello(name) {
    console.log(`Hello ! ${name}`)
}

/**
 * callback /listner /handler :
 *   It is a function gets registered for listening events
 * 
 */

function delay(callback) {
    //non blocking api :register handler with timer
    setTimeout(callback, 5000, "Hello,I am because of timer event")
}

sayHello('subramanian'); // block until function gets closed
delay(function (data) {
    console.log(data)
});
sayHello('foo'); // block until function gets closed

..............................................................................................
			Callback Based Programming


1.callback nesting/ callback composition:


In sync programming the application work flow to be designed like below.

i have apis  -  getUser,login,showPage

let user = getUser()

let status =login(user)

let page = showPage(status)

Class.forName()
DriverManager.getConnection()
con.executeStatement()
statement.executeQuery();

The above is sync composition work flow, 

How to write in async?
  Callback nesting/Compostion


//resolve - hanlding success
//reject -handling failures
const getUser = (resolve, reject) => {
    //biz 
    let user = {
        id: 1,
        name: 'admin'
    }
    //user = null;
    if (user) {
        setTimeout(resolve, 1000, user);
    } else {
        setTimeout(reject, 1000, { error: 'User not found!' });
    }
}
//output of getuser will be input to the login
const login = (user, resolve, reject) => {
    //biz
    if (user.name === 'admin') {
        setTimeout(resolve, 1000, 'login success')
    }
    else {
        setTimeout(reject, 1000, 'login failed')
    }
}

const showPage = (status, resolve, reject) => {
    //biz
    if (status === 'login success') {
        setTimeout(resolve, 1000, 'You are admin')
    }
    else {
        setTimeout(reject, 1000, 'You are guest')
    }
}


getUser((user) => {
    console.log('user is found', user)
    //call login
    login(user, status => {
        console.log(status)
        //call show page
        showPage(status, page => {
            console.log(page)
        }, error => {
            console.log(error);
        })
    }, error => {
        console.log('error', error);
    })
}, (error) => {
    console.log('error', error);
});


Nested Callbacks, Callback Hell:

Questions:

1.Whether this code is able to understand quickly
2.Whether this code is able to debug
3.Whehter this code is scalable?
4.whether this code is maintaiable?

Yes
 "Callback Hell"

fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})


Callback Hell:

 -It is not bug or error in code
 -It is way of writing callback based program
 -Callback based non blocking programming hard to understand,maintain,debug,scale Which 
  called as "Callback Hell".



How to write better async/non blocking code without callbacks?

-Generally without callbacks not possible to write async/non blocking code.
-Rather we can abstract complexity of writting callbacks.


In 2005, JQUERY team started with working complex callback patterns, they found callback hell problem.

They proposed a  Design pattern to write better callback programming(Async) programming.

  "Promise".

Promise is design pattern which hides complexity of callback patterns

Since Promise is design pattern, many people have implemented Promise design pattern.

1.JQuery -first promise implementation
2.many libs and frameworks


...........................................................................................

In order standarize , ECMA committe decided to include Promise Design pattern at language level .(ES 6)
2012 E6 Committe introduced promise design pattern  as  "Promise" Object  in javascript.


Promise is object which is the implementation of "Promise Design".


features of Promise Object:

1.Promise by deafult is Async. Which implements timer api with 0 ms .

Promise can be used with any async callback based  implementations.

Objective:

 To remove callbacks in async/non blocking code. write cleaner async programming.
 To remove complex callback chaining code.

Promise Implemenation:

1. Create Promise Object from Promise contructor
2. Create Promise object from factory apis 

Promise object methods:
1.then - success
2.catch - errors
3.finally - clean up
factory api to create Promise object
4.resolve
5.reject
.......................................
6.all
7.race


Use case : Promise is by default Async.

//Promise Object creation : Factory api

function sayHello(name){
  console.log(`Hello ${name}`)
}

//Promise by default is async
function delay() {
    return Promise.resolve('success') // Promise Object is returned
}

sayHello('foo')
delay().then(res=>console.log(res))
sayHello('bar')


Errors Handling:
//Promise Object creation : Factory api

function sayHello(name) {
    console.log(`Hello ${name}`)
}

//Promise by default is async
function delay() {
    return Promise.reject(new Error('something went wrong')) // Promise Object is returned
}

sayHello('foo')
delay().catch(err => console.log(err))
sayHello('bar')


both success and error : biz logic

//Promise Object creation : Factory api

function sayHello(name) {
    console.log(`Hello ${name}`)
}

//Promise by default is async
function delay(message) {
    if (message === 'hello') {
        return Promise.resolve(message)
    } else {
        return Promise.reject('Sorry!')
    }
}

sayHello('foo')
delay('hello')
    .then(message => console.log(message))
    .catch(err => console.log(err))
sayHello('bar')
.............................................................................................
				Promise Constructor Pattern
..............................................................................................


1.Used to create promise Object using new keyword
2.Usefull for abstracting existing callback programming

new Promise(function(resolve,reject){

})


const getUser = () => {
    //biz 
    let user = {
        id: 1,
        name: 'admin'
    }
    return new Promise((resolve, reject) => {
        if (user) {
            setTimeout(resolve, 1000, user);
        } else {
            setTimeout(reject, 1000, { error: 'User not found!' });
        }
    })

}

getUser()
    .then(user => {
        console.log(user)
    })
    .catch(error => {
        console.log(error);
    })

...

Callback hell and Promises:
..........................
const getUser = () => {
    //biz 
    let user = {
        id: 1,
        name: 'admin'
    }
    return new Promise((resolve, reject) => {
        if (user) {
            setTimeout(resolve, 1000, user);
        } else {
            setTimeout(reject, 1000, { error: 'User not found!' });
        }
    })

}

//output of getuser will be input to the login
const login = user => {
    //biz
    return new Promise((resolve, reject) => {
        if (user.name === 'admin') {
            setTimeout(resolve, 1000, 'login success')
        }
        else {
            setTimeout(reject, 1000, 'login failed')
        }
    })
}

const showPage = status => {
    return new Promise((resolve, reject) => {
        //biz
        if (status === 'login success') {
            setTimeout(resolve, 1000, 'You are admin')
        }
        else {
            setTimeout(reject, 1000, 'You are guest')
        }
    })
}


// getUser((user) => {
//     console.log('user is found', user)
//     //call login
//     login(user, status => {
//         console.log(status)
//         //call show page
//         showPage(status, page => {
//             console.log(page)
//         }, error => {
//             console.log(error);
//         })
//     }, error => {
//         console.log('error', error);
//     })
// }, (error) => {
//     console.log('error', error);
// });

// getUser().then(user => {
//     login(user)
//         .then(status => {
//             showPage(status).then(page => {
//                 console.log(page);
//             }).catch(err => {
//                 console.log(err);
//             })
//         })
//         .catch(err => {
//             console.log(err);
//         })
// }).catch(err => {
//     console.log(err);
// })



// getUser().then(user => {
//     return login(user)
// })
// .then(status => {
//         return showPage(status);
//     })
// .then(page => {
//         console.log(page);
// })
// .catch(err => {
//         console.log(err);
// })

// getUser()
//     .then(user => login(user))
//     .then(status => showPage(status))
//     .then(page => console.log(page))
//     .catch(err => {
//         console.log(err);
//     })

//
const { log } = console;

getUser()
    .then(login)
    .then(showPage)
    .then(log)
    .catch(log)
.....................................................................................
//////////////////////////////////////////////////////////////////////////////////////////

Promise Hell:

 In large code base, you can see many "thenables", how to reduce thenables.

ES 7 introduced even simple keywords , looks like sync programm/sequencial call.
"Sync style of async programm"

"async function and await keyword.


How to refactor the above code.

async...await keywords

Promise Hell: Promise has limitions;
......................

1.Promise is still  complex when you start scalling complex async operations.

2.Which is not readable ,which uses lot of then, catch blocks

In order to write even simple complex async work flows ES 7 introduced
a concept called "async await" keywords


 It is simplest pattern of Promises.
 It is promise driven only.

         "Sync style of Async Code" 

async key must be used with function declaration.
await is used to pause async calls


async ;

-used in front of function declaration ; those functions are called async function.

async is keyword must be used infront of function- async functions




const getUser = () => {
    //biz 
    let user = {
        id: 1,
        name: 'admin'
    }
    return new Promise((resolve, reject) => {
        if (user) {
            setTimeout(resolve, 1000, user);
        } else {
            setTimeout(reject, 1000, { error: 'User not found!' });
        }
    })

}

//output of getuser will be input to the login
const login = user => {
    //biz
    return new Promise((resolve, reject) => {
        if (user.name === 'admin') {
            setTimeout(resolve, 1000, 'login success')
        }
        else {
            setTimeout(reject, 1000, 'login failed')
        }
    })
}

const showPage = status => {
    return new Promise((resolve, reject) => {
        //biz
        if (status === 'login success') {
            setTimeout(resolve, 1000, 'You are admin')
        }
        else {
            setTimeout(reject, 1000, 'You are guest')
        }
    })
}

///////////////////////////////////////////////////////////////////////////////////


//using thenables
// function init() {
//     getUser()
//         .then(user => login(user))
//         .then(status => showPage(status))
//         .then(page => console.log(page))
//         .catch(err => {
//             console.log(err);
//         })
// }

//async ...await keywords

async function init() {
    try {
        let user = await getUser();
        let status 	= await login(user);
        let page = await showPage(status)
        console.log(user, status, page);
    }
    catch (err) {
        console.log(err)
    }
}

init();
....................................................................................
				Modularity
.....................................................................................
Modularity:
..........

In java Modularity , is presented via "Packages"

Package organize the code  logically.

Customer.java

package com.ibm.cms

public class Customer{}

Java organizes code folders and files Physically.

d:/javaapps/src/
    com/ibm/cms/Customer.java


What about javascript Modularity?

 Javascript is file based modularity physically
 but logically there is no such modularity at language level.

collection of variable declarations and function.

Once js started growing in large scale, dev struck to organize code.

2000, Smart developers started thinking about how to modualrize js code.

Module design patterns came.

1.Namespace design pattern : 2000 : jquery
2.AMD -Async Module Defintion : dojo
---------------------------------------------------------
3.CJS - Common JS =  namespace + amd
4.ES 6 Module design pattern  = amd + cjs
------------------------------------------------------------
5.System = AMD = CJS + ES 6
6.UMD = NAMESPACE + AMD + CJS = ES 6


only two design patterns are used in development

1.CJS - Common JS =  namespace + amd
2.ES 6 Module design pattern  = amd + cjs

CJS ; implemented inside node js. node supports commonjs by default.

I can organize the code , based on these patterns, but what about runtimes?
  js runtime never suppport these patterns directly then each design pattern is lib.

 Loaders : it is simple js lib to help link and load js files.

////////////////////////////////////////////////////////////////////////////////////////////

lets start cjs first;
......................

cjs is built in node js.
node supports cjs in built. no separate loader or linker is required
but if you run cjs code on browsers , we need loaders.


How to implement cjs in node? How to share code across the files and how to link files


keywords

-require('./folder/fileName')
  to link files
-exports
   -used to share code in form of object
   -code is packed inside object and share that object
-module.exports
   -used to share code as it is.


src/mylib.js

//code to be shared
console.log('hello module')

//link file
require('./mylib')


How to share code ?

code : could be any thing 
primitives, objects,functions,classes.....

exports is just built in variable, whose value is object, through which only we share code.

let a =10;

let exports = ?

The value of exports variable by default is "empty literal object "


require('./mylib') - it is function which may return "object" / something.

...

src/mylib.js

//code to be shared
// console.log('hello module')

// const firstName ='Subramanian';

exports.firstName = 'Subramanian'
exports.lastName = 'M'
exports.salary = 1000
exports.isActive = true
exports.address = {
    city: 'Coimbatore'
}
exports.skills = ['node','microservices']

src/index.js
//link file
// const myresult = require('./mylib')
// console.log(myresult)

// console.log(myresult.firstName ,myresult.lastName,myresult.address.city)

const { firstName, lastName, address: { city } } = require('./mylib');

console.log(firstName, lastName, city)


How to use module.exports.

-can export only one thing at time


src/employee.js

class Employee {

    getEmployeeInfo() {
        return 'Employee info'
    }
}

//how to export
module.exports = Employee

................

src/services/user.service.js
const USERS = require("../mock-data/users");

class UserService {

    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 5000, USERS);
        })
    }
}

// module.exports = UserService;
module.exports = new UserService()

src/index.js

// const UserService = require("./services/user.service");
const { findAll } = require("./services/user.service");

async function main() {
    // let userService = new UserService();
    // let users = await userService.findAll();
    let users = await findAll();

    console.log(users);
}
main();
.....................................................................................

Types of modules:

1.custom module
  built by us
2.built in modules
   provided by node.js  
3.provided by third party/community
  libs,frameworks



1.custom module
  built by us  - already discussed

Node js Built in modules:
..........................

File System io

Networking

etc...

https://nodejs.org/dist/latest-v17.x/docs/api/os.html

1.os 

The os module provides operating system-related utility methods and properties. It can be accessed using:

const os = require('os')

// console.log(os)
console.log(`Total Memory ${os.totalmem()}`)
console.log(`Machine Arc ${os.arch()}`)
console.log(os.cpus())
.....................................................................................

./ vs ''(without ./)
.........

 require('./services/TODOService');
  ->here you can see ./
  ./ -current dir

 require('os'); => 
  -here no ./ 

Why?

Note : if you are java devp, you know the classpath , how it works?


require('os');

Node internally uses a search algorthim,node always looks the folder called
 "node_modules" in the current project, if not , then it searches, the node in built 
installtion folder---C:\Program Files\nodejs\node_modules--if it finds it will pick up from there else it will throw error.

Error: Cannot find module 'osxx'
Require stack:
- C:\session\ibm\feb\nodems\mynodeapps\src\index.js
[90m    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:797:15)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:690:27)[39m
[90m    at Module.require (internal/modules/cjs/loader.js:852:19)[39m
[90m    at require (internal/modules/cjs/helpers.js:74:18)[39m
    at Object.<anonymous> (C:\session\ibm\feb\nodems\mynodeapps\src\index.js:1:32)
[90m    at Module._compile (internal/modules/cjs/loader.js:959:30)[39m
[90m    at Object.Module._extensions..js (internal/modules/cjs/loader.js:995:10)[39m
[90m    at Module.load (internal/modules/cjs/loader.js:815:32)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:727:14)[39m
[90m    at Function.Module.runMain (internal/modules/cjs/loader.js:1047:10)[39m {
  code: [32m'MODULE_NOT_FOUND'[39m,
  requireStack: [ [32m'C:\\session\\ibm\\feb\\nodems\\mynodeapps\\src\\index.js'[39m ]
}
//////////////////////////////////////////////////////////////////////////////////////////
			Event Emitter Module: events

Much of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called "emitters") emit named events that cause Function objects ("listeners") to be called.

-How to built event driven arch.

-Most of high level non blocking apis like fs ,net uses events module underneeth.

How to create custom events and listen for them.

-producer-emitter who emits event and data.
-listener

//event emitter module.

const EventEmitter = require('events')

//emiter
class CustomerService extends EventEmitter {
    constructor() {
        super();
        //registering event ; sales is custom event
        this.on('sales', (data) => {
            setTimeout(() => console.log('data', data), 1000)
        })
     }
    buy(product) {
        this.emit('sales', product) //send /emit an event 
    }
}
let custService = new CustomerService();
custService.buy({ id: 1, name: 'Node.js In Action', category: 'book', price: 100 })
custService.buy({ id: 2, name: 'libuv.js In Action', category: 'book', price: 100 })
.....................................................................................
				IO 

IO:
-FS : disk io
-Socket io/networking

NonBlocking IO And Blocking:

-node supports even blocking io. only disk io in blocking way
-node does not support blocking networking io.

File System:fs
...............

-used to read , write into and from disk.

mode :

  - sync /blocking 
  - async/ non blocking

based on data read/write:

 -non streaming
 -streaming
....................................................................................
			How to read disk file using non blocking io api ?

Which thread can be used to read file from disk?

A.Event Loop Thread
B.Worker loop thread

Ans:
 Worker loop thread.


//fs
const fs  = require('fs');

function block(message){
    console.log(message)
}

const filePath = './src/assets/info.txt';

const options = {
    encoding: 'UTF-8'
}

block('start')

fs.readFile(filePath, options, (err, data) => {
    if (err) throw err;
    console.log(data)
})

block('end')

////////////////////////////////////////////////////////////////////////////////////////////

Sync : Version of File IO:read
const fs = require('fs')

function block(message) {
    console.log(message)
}

const filePath = './src/assets/info.txt';
const options = {
    encoding: 'UTF-8'
}
block('start')
const data = fs.readFileSync(filePath, options)
console.log(data)
block('end')
/

//////////////////////////////////////////////////////////////////////////////////////////

How to write data into file async:



const fs = require('fs');

const filePath = './src/assets/infowrite.txt';

const options = {
    encoding: 'utf-8'
}
const data = 'Hello,How are you';

fs.writeFile(filePath, data, options, err => {
  if (err) throw err;
  console.log(`data has been written into ${filePath}`)
})
//////////////////////////////////////////////////////////////////////////////////////////

How to write data into file async:

const fs = require('fs');

const filePath = './src/assets/infowrite.txt';
const options = {
    encoding: 'utf-8'
}
const data = 'Hello,How are you';

fs.writeFile(filePath, data, options, err => {
  if (err) throw err;
  console.log(`data has been written into ${filePath}`)
})
////////////////////////////////////////////////////////////////////////////////////////////
How to avoid file path hardcoding?

path module:

The path module provides utilities for working with file and directory paths. It can be accessed using:

Node js global variables:

-node provides lot of global variables

__dirname  : current directory name
C:\session\ibm\2021\june\nodemicroservices\nodeapps\src

__filename :current directory name + fileName
C:\session\ibm\2021\june\nodemicroservices\nodeapps\src\index.js

const fs = require('fs');
const path = require('path');

console.log(__dirname)
console.log(__filename)
// const filePath = './src/assets/infowrite.txt';
const filePath = path.join(__dirname,'assets/infowrite.txt')
const options = {
    encoding: 'utf-8'
}
const data = 'Hello,How are you';

fs.writeFile(filePath, data, options, err => {
  if (err) throw err;
  console.log(`data has been written into ${filePath}`)
})
////////////////////////////////////////////////////////////////////////////////////////////

IO operations can be performed in two ways

1.Non Streaming way

2.Streaming way


HTTP Application

.....
NPM
Frameworks
REST full
Microservices










































































































